# Import some installed modules.
import numpy as np
from scipy.spatial import KDTree

# DO NOT EDIT THIS FILE

# The Model class emulates the robot's learned model.
# It enables the robot to make predictions about the effect of its actions on its state.
# The model has uncertainty, which reduces over time as the robot explores the state-action space.
# Visualising the model (set draw_model = True in robot-learning.py) enables you to see what the model currently predicts.
# This also allows you to see the current uncertainty, because each time a prediction is drawn, it is sampled from the uncertainty distribution.
class Model:

    # Initialise.
    def __init__(self, environment):
        self.environment = environment
        self.kd_tree = None
        self.transitions = np.empty(shape=[0, 4], dtype=np.float32)
        self.knn = 10
        self.action_coeff = 10

    # Make a prediction about the next state, given the current state and action.
    def predict(self, state, action):
        # If there are only a few transitions available, return a large uncertainty.
        if len(self.transitions) < self.knn:
            uncertainty = 0.1
        else:
            # Calculate the uncertainty
            query = np.array([state[0], state[1], self.action_coeff * action[0], self.action_coeff * action[1]])
            distances, _ = self.kd_tree.query(query, k=self.knn)
            mean_distance = np.mean(distances)
            uncertainty = 0.3 * np.power(mean_distance, 3)
        # True dynamics
        true_next_state = self.environment.dynamics(state, action)
        # Compute the predicted next state, with the uncertainty incorporated
        predicted_next_state = true_next_state
        predicted_next_state[0] += np.random.normal(loc=0, scale=uncertainty)
        predicted_next_state[1] += np.random.normal(loc=0, scale=uncertainty)
        # Return this predicted state
        return predicted_next_state, uncertainty

    # Update the uncertainty based on a particular state and action transition.
    def update_uncertainty(self, state, action):
        new_transition = np.array([[state[0], state[1], self.action_coeff * action[0], self.action_coeff * action[1]]])
        self.transitions = np.append(self.transitions, new_transition, axis=0)
        self.kd_tree = KDTree(self.transitions)
